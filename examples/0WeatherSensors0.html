<html>
    <head>
        <title>TSI Weather Sensors</title>

        <style type="text/css">
            #miniDiv {
                display: block;
                margin-bottom: 20px;
                margin-right: 20px;
                position: absolute;
                width:100px;
                height:100px;
                left: 20;
                bottom: 0;
                color: white;
            }
        </style>
        <meta charset="UTF-8">
        <link rel="stylesheet" type="text/css" href="css/example.css">
        <link rel="stylesheet" type="text/css" href="css/loading_screen.css">

        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <script src="js/GUI/dat.gui/dat.gui.min.js"></script>
    </head>
    <body>
        <div id="viewerDiv">
            <span class="divScaleWidget"> Scale </span>
            <div id="miniDiv">
            </div>
        </div>
        <script src="js/GUI/GuiTools.js"></script>
        <script src="../dist/itowns.js"></script>
        <script src="js/loading_screen.js"></script>
        <script src="../dist/debug.js"></script>
        <script type="text/javascript">

            // Define initial camera position
            var positionOnGlobe = { longitude: 2.351323, latitude: 48.856712, altitude: 2800000 };
            var miniView;
            var minDistance = 10000000;
            var maxDistance = 30000000;

            // `viewerDiv` will contain iTowns' rendering area (`<canvas>`)
            var viewerDiv = document.getElementById('viewerDiv');
            var miniDiv = document.getElementById('miniDiv');

            // Instanciate iTowns GlobeView*
            var view = new itowns.GlobeView(viewerDiv, positionOnGlobe);
            setupLoadingScreen(viewerDiv, view);

            // **************** WEATHER SENSORS GLOBAL VARIABLES ************************
            // Urls of all sensors
            var allSensors = [
                {text: 'Sonde YSH', value: 'piensg010:3001'},
                {text: 'Sonde MCM', value: 'piensg009:3000'}, 
                {text: 'Sonde BMW', value: 'piensg011:3001'}
            ];
            var markers = [];
            var colorPalette= [0xfc4a1a, 0x4abdac, 0xf7b733];
            // ***************************************************************************

            // Dont' instance mini viewer if it's Test env
            miniView = new itowns.GlobeView(miniDiv, positionOnGlobe, {
                // `limit globe' subdivision level:
                // we're don't need a precise globe model
                // since the mini globe will always be seen from a far point of view (see minDistance above)
                maxSubdivisionLevel: 2,
                // Don't instance default controls since miniview's camera will be synced
                // on the main view's one (see view.addFrameRequester)
                noControls: true,
            });

            // Set a 0 alpha clear value (instead of the default '1')
            // because we want a transparent background for the miniglobe view to be able
            // to see the main view "behind"
            miniView.mainLoop.gfxEngine.renderer.setClearColor(0x000000, 0);

            // update miniview's camera with the view's camera position
            view.addFrameRequester(itowns.MAIN_LOOP_EVENTS.AFTER_RENDER, function updateMiniView() {
                // clamp distance camera from globe
                var distanceCamera = view.camera.camera3D.position.length();
                var distance = Math.min(Math.max(distanceCamera * 1.5, minDistance), maxDistance);
                var camera = miniView.camera.camera3D;
                var cameraTargetPosition = view.controls.getCameraTargetPosition();
                // Update target miniview's camera
                camera.position.copy(cameraTargetPosition).setLength(distance);
                camera.lookAt(cameraTargetPosition);
                miniView.notifyChange(camera);
            });

            // Add one imagery layer to the scene and the miniView
            // This layer is defined in a json file but it could be defined as a plain js
            // object. See Layer* for more info.
            itowns.Fetcher.json('./layers/JSONLayers/Ortho.json').then(function _(config) {
                config.source = new itowns.WMTSSource(config.source);
                var layer = new itowns.ColorLayer('Ortho', config);
                view.addLayer(layer).then(menuGlobe.addLayerGUI.bind(menuGlobe));

                var miniLayer = new itowns.ColorLayer('OrthoMini', config);
                miniView.addLayer(miniLayer);
            });

            var menuGlobe = new GuiTools('menuDiv', view);
            var divScaleWidget = document.querySelectorAll('.divScaleWidget')[0];

            function updateScaleWidget() {
                var value = view.controls.pixelsToMeters(200);
                value = Math.floor(value);
                var digit = Math.pow(10, value.toString().length - 1);
                value = Math.round(value / digit) * digit;
                var pix = view.controls.metersToPixels(value);
                var unit = 'm';
                if (value >= 1000) {
                    value /= 1000;
                    unit = 'km';
                }
                divScaleWidget.innerHTML = `${value} ${unit}`;
                divScaleWidget.style.width = `${pix}px`;
            }

            // ********************************* METEO APP CALLS *************************************


            // ************************* WEATHER SENSORS APP FUNCTIONS DECLARATIONS ****************************

            // fetch location of all sensors
            function getPositions(){
                var promises = [];
                for (let i = 0; i < allSensors.length; i++) {
                    promises.push(
                        fetch('http://'+allSensors[i].value+'/last?capteur_type=location')
                        .then(result => result.json())
                        .catch(() => null)
                    );
                }
                Promise.all(promises)
                .then(promises => {
                    for (let i = 0; i < promises.length; i++) {
                        if( promises[i] !=null && promises[i].location !== undefined){
                            var position = {
                                lng: Number(promises[i].location.lng), 
                                lat: Number(promises[i].location.lat) 
                            };
                            addMarkerToScene(position, i); 
                            markers.push({
                                sonde: allSensors[i].text, 
                                mesh: view.mesh
                            })
                        }
                    }                   
                })
            } 

            function addMarkerToScene(position, i) {

                // creation of the new mesh (a cylinder)
                var THREE = itowns.THREE;
                var geometry = new THREE.CylinderGeometry(0, 20000, 60000, 16);
                var material = new THREE.MeshBasicMaterial({ color: colorPalette[i] });
            
                var mesh = new THREE.Mesh( geometry.translate(0, -30000, 0), material);

                const coords = new itowns.Coordinates('EPSG:4326', position.lng, position.lat, 0); // Geographic system
                const coordinates = coords.as('EPSG:4978'); // Geocentric system

                // position of the mesh
                var meshCoord = coordinates;

                // position and orientation of the mesh
                mesh.position.copy(meshCoord.as(view.referenceCrs).xyz());
                mesh.lookAt(new THREE.Vector3(0, 0, 0));
                mesh.rotateX(Math.PI / 2);
                // update coordinate of the mesh
                mesh.updateMatrixWorld();
                // add the mesh to the scene
                view.scene.add(mesh);
                // make the object usable from outside of the function
                view.mesh = mesh;
            }

            function updateScaleMarker() {
                for (let i = 0; i < markers.length; i++) {
                    var value = view.controls.pixelsToMeters(33) / 60000 ;
                    markers[i].mesh.scale.set(value,value,value);
                    markers[i].mesh.updateMatrixWorld();
                }
            }

            // **************************************************************************************

            // Listen for globe full initialisation event
            view.addEventListener(itowns.GLOBE_VIEW_EVENTS.GLOBE_INITIALIZED, function () {
                // eslint-disable-next-line no-console
                console.info('Globe initialized');
                updateScaleWidget();
                view.controls.setTilt(60, true);
                //METEO APP CALL: get positions of all sensors
                getPositions(); 

            });
            view.controls.addEventListener(itowns.CONTROL_EVENTS.RANGE_CHANGED, () => {
                updateScaleWidget();
                updateScaleMarker();
            });

        </script>
    </body>
</html>
