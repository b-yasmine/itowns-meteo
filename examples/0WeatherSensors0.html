<html>
    <head>
        <title>TSI Weather Sensors</title>

        <style type="text/css">
            #miniDiv {
                display: block;
                margin-bottom: 20px;
                margin-right: 20px;
                position: absolute;
                width:100px;
                height:100px;
                left: 20;
                bottom: 0;
                color: white;
            }
        </style>
        <meta charset="UTF-8">
        <link rel="stylesheet" type="text/css" href="css/example.css">
        <link rel="stylesheet" type="text/css" href="css/loading_screen.css">

        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <script src="js/GUI/dat.gui/dat.gui.min.js"></script>
    </head>
    <body>
        <div id="viewerDiv">
            <span class="divScaleWidget"> Scale </span>
            <div id="miniDiv">
            </div>
        </div>
        <script src="js/GUI/GuiTools.js"></script>
        <script src="../dist/itowns.js"></script>
        <script src="js/loading_screen.js"></script>
        <script src="../dist/debug.js"></script>
        <script type="text/javascript">
        
            // Define initial camera position
            var positionOnGlobe = { longitude: 2.351323, latitude: 48.856712, altitude: 2800000 };
            var miniView;
            var minDistance = 10000000;
            var maxDistance = 30000000;
            // `viewerDiv` will contain iTowns' rendering area (`<canvas>`)
            var viewerDiv = document.getElementById('viewerDiv');
            var miniDiv = document.getElementById('miniDiv');
            // Instanciate iTowns GlobeView*
            var view = new itowns.GlobeView(viewerDiv, positionOnGlobe);
            setupLoadingScreen(viewerDiv, view);
            // **************** WEATHER SENSORS GLOBAL VARIABLES ************************
            // Urls of all sensors
            var allSensors = [
                {text: 'Sonde YSH', value: 'piensg010:3001', position: null},
                {text: 'Sonde MCM', value: 'piensg009:3000', position: null}, 
                {text: 'Sonde BMW', value: 'piensg011:3001', position: null}
            ];
            var colorPalette= [0xfc4a1a, 0x4abdac, 0xf7b733];
            var markers = [];
            var arrows = [];
            // ***************************************************************************
            // Dont' instance mini viewer if it's Test env
            miniView = new itowns.GlobeView(miniDiv, positionOnGlobe, {
                // `limit globe' subdivision level:
                // we're don't need a precise globe model
                // since the mini globe will always be seen from a far point of view (see minDistance above)
                maxSubdivisionLevel: 2,
                // Don't instance default controls since miniview's camera will be synced
                // on the main view's one (see view.addFrameRequester)
                noControls: true,
            });
            // Set a 0 alpha clear value (instead of the default '1')
            // because we want a transparent background for the miniglobe view to be able
            // to see the main view "behind"
            miniView.mainLoop.gfxEngine.renderer.setClearColor(0x000000, 0);
            // update miniview's camera with the view's camera position
            view.addFrameRequester(itowns.MAIN_LOOP_EVENTS.AFTER_RENDER, function updateMiniView() {
                // clamp distance camera from globe
                var distanceCamera = view.camera.camera3D.position.length();
                var distance = Math.min(Math.max(distanceCamera * 1.5, minDistance), maxDistance);
                var camera = miniView.camera.camera3D;
                var cameraTargetPosition = view.controls.getCameraTargetPosition();
                // Update target miniview's camera
                camera.position.copy(cameraTargetPosition).setLength(distance);
                camera.lookAt(cameraTargetPosition);
                miniView.notifyChange(camera);
            });
            // Add one imagery layer to the scene and the miniView
            // This layer is defined in a json file but it could be defined as a plain js
            // object. See Layer* for more info.
            itowns.Fetcher.json('./layers/JSONLayers/Ortho.json').then(function _(config) {
                config.source = new itowns.WMTSSource(config.source);
                var layer = new itowns.ColorLayer('Ortho', config);
                view.addLayer(layer).then(menuGlobe.addLayerGUI.bind(menuGlobe));
                var miniLayer = new itowns.ColorLayer('OrthoMini', config);
                miniView.addLayer(miniLayer);
            });
            var menuGlobe = new GuiTools('menuDiv', view);
            var divScaleWidget = document.querySelectorAll('.divScaleWidget')[0];
            function updateScaleWidget() {
                var value = view.controls.pixelsToMeters(200);
                value = Math.floor(value);
                var digit = Math.pow(10, value.toString().length - 1);
                value = Math.round(value / digit) * digit;
                var pix = view.controls.metersToPixels(value);
                var unit = 'm';
                if (value >= 1000) {
                    value /= 1000;
                    unit = 'km';
                }
                divScaleWidget.innerHTML = `${value} ${unit}`;
                divScaleWidget.style.width = `${pix}px`;
            }
            // ********************************* METEO APP CALLS *************************************
            // ************************* WEATHER SENSORS APP FUNCTIONS DECLARATIONS ****************************
            // fetch location of all sensors
            function getPositions(){
                var promises = [];
                for (let i = 0; i < allSensors.length; i++) {
                    if( allSensors[i].position == null) {
                        promises.push(
                            fetch('http://'+allSensors[i].value+'/last?capteur_type=location')
                            .then(result => result.json())
                            .catch(() => {
                                return (
                                    // If sensor not working use the sample json files
                                    fetch('./json_samples/last_all_'+allSensors[i].value+'.json')
                                    .then(result => result.json())
                                );
                            })
                        );
                    }
                }
                Promise.all(promises)
                .then(promises => {
                    for (let i = 0; i < promises.length; i++) {
                        if( promises[i] !=null && promises[i].location !== undefined){
                            var position = {
                                lng: Number(promises[i].location.lng), 
                                lat: Number(promises[i].location.lat) 
                            };
                            allSensors[i].position = position;
                            addMarkerToScene(position, i); 
                            markers.push({
                                sonde: allSensors[i].text, 
                                mesh: view.mesh
                            })
                        }
                    }                   
                })
            }

            function addMarkerToScene(position, i) {

                // creation of the new mesh (a cylinder)
                var THREE = itowns.THREE;
                var geometry = new THREE.CylinderGeometry(0, 20000, 60000, 16);
                var material = new THREE.MeshBasicMaterial({ color: colorPalette[i] });
            
                var mesh = new THREE.Mesh( geometry.translate(0, -30000, 0), material);

                const coords = new itowns.Coordinates('EPSG:4326', position.lng, position.lat, 0); // Geographic system
                const coordinates = coords.as('EPSG:4978'); // Geocentric system

                // position of the mesh
                var meshCoord = coordinates;

                // position and orientation of the mesh
                mesh.position.copy(meshCoord.as(view.referenceCrs).xyz());
                mesh.lookAt(new THREE.Vector3(0, 0, 0));
                mesh.rotateX(Math.PI / 2);
                // update coordinate of the mesh
                mesh.updateMatrixWorld();
                // add the mesh to the scene
                view.scene.add(mesh);
                // make the object usable from outside of the function
                view.mesh = mesh;
            }

            // fetch a measurement type from all sensors and pass it to the callback function
            function getMeasurement(type, callback){
                var promises = [];
                for (let i = 0; i < allSensors.length; i++) {
                    promises.push(
                        fetch('http://'+allSensors[i].value+'/last?capteur_type='+type)
                        .then(result => result.json())
                        .catch(() => {
                            return (
                                // If sensor not working use the sample json files
                                fetch('./json_samples/last_all_'+allSensors[i].value+'.json')
                                .then(result => result.json())
                            );
                        })
                    );
                }
                Promise.all(promises)
                .then(promises => {
                    for (let i = 0; i < promises.length; i++) {
                        if( promises[i] !=null && promises[i].measurements[type] !== undefined){
                            var measurement = promises[i].measurements[type];
                            callback(measurement,i);
                        }
                    }                   
                })    
            } 
            function addMarkerToScene(position, i) {
                // creation of the new mesh (a cylinder)
                var THREE = itowns.THREE;
                var geometry = new THREE.CylinderGeometry(0, 20000, 60000, 16);
                var material = new THREE.MeshBasicMaterial({ color: colorPalette[i] });
            
                var mesh = new THREE.Mesh( geometry.translate(0, -30000, 0), material);
                const coords = new itowns.Coordinates('EPSG:4326', position.lng, position.lat, 0); // Geographic system
                const coordinates = coords.as('EPSG:4978'); // Geocentric system
                // position of the mesh
                var meshCoord = coordinates;
                // position and orientation of the mesh
                mesh.position.copy(meshCoord.as(view.referenceCrs).xyz());
                mesh.lookAt(new THREE.Vector3(0, 0, 0));
                mesh.rotateX(Math.PI / 2);
                //update coordinate of the mesh
                mesh.updateMatrixWorld();
                // add the mesh to the scene
                view.scene.add(mesh);
                // make the object usable from outside of the function
                view.mesh = mesh;
            }

            // Show an arrow that points to the wind direction for all sensors / markers
            function showWindArrows(){ 
                getMeasurement("wind_dir", showWindArrow_callback);
            }
            
            // Callback function that creates an oriented arrow using the wind_dir measurement
            function showWindArrow_callback(angle,i){
                addArrowToScene(angle,i);
                // Keeping arrows as a global variable
                arrows.push({
                    mesh: view.mesh
                });
            }
            
            function addArrowToScene(angle,i) {
                var THREE = itowns.THREE;
                // draw 2D arrow
                var shape = new THREE.Shape();
				shape.moveTo( 15000, 10000 );
				shape.lineTo( 0, -30000 );
				shape.lineTo( -15000, 10000 );
                shape.lineTo( -5000, 10000 );
                shape.lineTo( -5000, 30000 );
                shape.lineTo( 5000, 30000 );
                shape.lineTo( 5000, 10000 );
				shape.lineTo( 15000, 10000 ); 
                // extrude settings for the arrow  
                var extrudeSettings = { 
                    depth: 8000, 
                    bevelEnabled: true, 
                    bevelSegments: 2000, 
                    steps: 2000, 
                    bevelSize: 1000, 
                    bevelThickness: 1000 
                };
                var material = new THREE.MeshBasicMaterial({ color: 0xcecece });
                // 3D arrow (extruded)
                var geometry = new THREE.ExtrudeBufferGeometry( shape, extrudeSettings );
                // rotate arrow with wind direction angle in rad
                geometry = geometry.rotateZ((angle * Math.PI / 180));
                // translate arrow to top left corner
                geometry = geometry.translate(40000, -100000, 0);
                // create the mesh
                var mesh = new THREE.Mesh(geometry, material);
                // position the arrow mesh at the corresponding marker
                mesh.position.set( 
                    markers[i].mesh.position.x, 
                    markers[i].mesh.position.y, 
                    markers[i].mesh.position.z );
                mesh.lookAt(new THREE.Vector3(0, 0, 0));
                mesh.rotateX(Math.PI / 2);
                //update coordinate of the mesh
                mesh.updateMatrixWorld();
                // add the mesh to the scene
                view.scene.add(mesh);
                // make the object usable from outside of the function
                view.mesh = mesh;
            }

            // 
            function updateScaleMeshes(meshes, meterValue, pixelValue) {
                for (let i = 0; i < meshes.length; i++) {
                    var value = view.controls.pixelsToMeters(pixelValue) / meterValue;
                    meshes[i].mesh.scale.set(value,value,value);
                    meshes[i].mesh.updateMatrixWorld();
                }
            }

            // TEXT ENSG
            var meshText;
            function showText(){
                var loader = new itowns.THREE.FontLoader();
                loader.load( 'helvetiker_regular.typeface.json', function ( font ) {
                var textGeometry = new itowns.THREE.TextGeometry( '10°C', {
                        font: font,
                        size: 50000,
                        height: 2000,
                        curveSegments: 120,
                        bevelEnabled: true,
                        bevelThickness: 1000,
                        bevelSize: 8,
                        bevelSegments: 100
                    } );
                meshText = new itowns.THREE.Mesh(textGeometry, new itowns.THREE.MeshNormalMaterial());
                // Set the position
                var coordENSG = new itowns.Coordinates('EPSG:4326', 2.59, 48.8410, 200000);             
                meshText.position.copy(coordENSG.as(view.referenceCrs).xyz());
                // Set the orientation
                meshText.lookAt(new itowns.THREE.Vector3(0, 0, 0));
                meshText.rotateX(-Math.PI / 2);
                meshText.rotateY(Math.PI);
                // update coordinate of the mesh
                meshText.updateMatrixWorld();
                // add the mesh to the scene
                view.scene.add(meshText);
                // make the object usable from outside of the function
                view.mesh = meshText;
                } );
            }

            // **************************************************************************************
            // Listen for globe full initialisation event
            view.addEventListener(itowns.GLOBE_VIEW_EVENTS.GLOBE_INITIALIZED, function () {
                // eslint-disable-next-line no-console
                console.info('Globe initialized');
                updateScaleWidget();
                view.controls.setTilt(30, true);
                //METEO APP CALL: get positions of all sensors
                getPositions(); 
                console.log("showing welou ?");
                showText();
            });
            view.controls.addEventListener(itowns.CONTROL_EVENTS.RANGE_CHANGED, () => {
                updateScaleWidget();
                updateScaleMeshes(markers, 60000, 33);
                updateScaleMeshes(arrows, 40000, 22);
            });
        </script>
    </body>
</html>